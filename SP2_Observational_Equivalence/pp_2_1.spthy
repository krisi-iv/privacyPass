/*
Protocol: PP_2.1

Instructions to run: 
automatic: tamarin-prover pp_2_1.spthy --prove --derivcheck-timeout=500
interactive: tamarin-prover interactive pp_2_1.spthy --derivcheck-timeout=500

Results:
All wellformedness checks were successful.

Generated from:
Tamarin version 1.10.0
Maude version 3.1
Git revision: cb62c305f8c8b8c1e664152aa33c95b7b8d5ef32, branch: master
Compiled at: 2024-12-10 08:55:12.367514209 UTC
end
==============================================================================
summary of summaries:
analyzed: pp_2_1.spthy
  processing time: 122.37s
  correctness (exists-trace): verified (23 steps)
  adversary_generates_tokens (exists-trace): verified (9 steps)
  adversary_tokens_not_verified (all-traces): verified (11 steps)
  adversary_injects_msgs (exists-trace): verified (3 steps)
  adversary_injects_msgs_not_verified (all-traces): verified (13 steps)
==============================================================================
*/

theory PrivacyPassUnlinkability_P_2_1
begin

heuristic: O "pp_unlinkability.oracle"

builtins: multiset

functions: h1/1, h2/2, h3/6, blind/2, sign/2, unblind/2,
			pow/2, mod/2, multiply/2, minus/2,  
			calcA/1, calcB/1, CalcR/3,  
			MAC/2,
			//Partial deconstructions - Use strong typing to prevent PDs
			BlindedToken/1, SignedToken/1, 
			CHash/1, SMod/1
equations [convergent]:
    unblind(sign(blind(h1(x),r),secr_key),r) = sign(h1(x),secr_key),
	// Recalculate A in the DLEQ proof: A = X^s * Y^c = X^((t-(h3(X, Y, P, Q, Xt, Pt)*k)) mod q) * X^k^h3(X, Y, P, Q, Xt, Pt) = Xt, where t is a random nonce
    calcA(
        multiply(
            pow(X, mod(minus(t, multiply(h3(X, Y, P, Q, Xt, Pt), k)), q)),
            pow(pow(X, k), h3(X, Y, P, Q, Xt, Pt))
        )
        ) = Xt,
    // Recalculate B in the DLEQ proof: B = P^s * P^c = P^((t-(h3(X, Y, P, Q, Xt, Pt)*k)) mod q) * P^k^h3(X, Y, P, Q, Xt, Pt) = Pt, where t is a random nonce
    calcB(
        multiply(
            pow(P, mod(minus(t, multiply(h3(X, Y, P, Q, Xt, Pt), k)), q)),
            pow(sign(P, k), h3(X, Y, P, Q, Xt, Pt))
        )
    ) = Pt
	
// the following restriction is used to allow only a single instance of the token issuer to be created in the protocol for this implementation
restriction single_ti: "All #i #j ti Y sk1 ti2 Y2 sk2. Setup_Ti(ti, Y, sk1) @ i & Setup_Ti(ti2, Y2, sk2) @ j ==> #i = #j"
// used to check the solution is indeed correct, the equality in the DLEQ proof holds, the token is stored in the token issuer's data store, and the MACs are equal
restriction equality: "All #i x y. Eq(x , y) @ i ==> x = y"

// the following two rules are used to model the secure channel used in the protocol
rule ChanOut_S:
    [ Out_S($A,$B,x) ]
    --[ ChanOut_S($A,$B,x) ]->
    [ Sec($A,$B,x) ]

rule ChanIn_S:
    [ Sec($A,$B,x) ]
    --[ ChanIn_S($A,$B,x) ]->
    [ In_S($A,$B,x) ]

// allowing the TI to leak its secret key 
rule Ti_leaked_signing_key:
    [ LeakKeys($Ti, secr_key) ]
    --[ TiLeakedKey($Ti, secr_key) ]->
    [ Out(secr_key) ]

// setting up the token issuer with its secret key, the order of the group, the generators of the group, and the commitments
rule Setup_Ti:
    let Y = pow(X,secr_key)                                                                     // Y = X^sk
    in
    [ 
        Fr(X), 
        Fr(ord),                                                                                // the order of the group
        Fr(secr_key)                                                                            // the secret signing key of the token issuer
    ]
    --[ 
        Setup_Ti($Ti, Y, secr_key)
    ]->
    [ 
        LeakKeys($Ti, secr_key),
        State_Ti_setup($Ti, X, Y, ord, secr_key), 
        State_Srv_Ti($Ti, Y), 
        !State_Usr_Ti($Ti, X)
    ]

// setting up the server with the commitment of the token issuer and knowledge of the token issuer
rule Setup_Srv:
    [ 
        State_Srv_Ti($Ti, Y) 
    ]
    --[ 
        Setup_Srv($Ti, $Srv, Y)
    ]->
    [ 
        State_Srv_setup($Srv, $Ti, Y),
        !State_Srv_Usr($Srv, $Ti, Y)
    ]

// setting up the user with the commitment of the token issuer and knowledge of the server
rule Setup_Usr:
    [ 
        !State_Usr_Ti($Ti, X), 
        !State_Srv_Usr($Srv, $Ti, Y)
    ]
    --[ 
        Setup_Usr($Usr, $Srv, Y) 
    ]->
    [ 
        State_Usr_setup($Usr, $Srv, X, Y)
    ]

// User generates blinded tokens - 2 for user1 and 1 for user2 and sends them to the server over the insecure channel
rule Usr_send_token:
    let
        Usr1BlindedToken = blind(h1(~t),~r)                                                     // T=H(~t), blind T: T~ = T^r
        Usr1BlindedToken2 = blind(h1(~t1),~r1) 
        Usr2BlindedToken = blind(h1(~t2),~r2)
        seeds = <~t, ~t1, ~t2>
        tokens = <Usr1BlindedToken ++ Usr1BlindedToken2 ++ Usr2BlindedToken>
        msg = <'1', $Usr, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
    in
    [ 
        Fr(~t),                                                                                 // the users generate fresh seed values for the blinded tokens
        Fr(~t1), 
        Fr(~t2),
        Fr(~r),                                                                                 // the user generates fresh randomisation values for the blinded tokens
        Fr(~r1),
        Fr(~r2),
        State_Usr_setup($Usr, $Srv, X, Y)
    ]
    --[ SendToken($Usr, $Srv, tokens, seeds) ]->
    [ 
		Out(<$Usr, $Srv, msg>),                                                                 // send the blinded tokens to the server insecurely
		State_Usr_blind($Usr, $Srv, X, Y, ~t, ~t1, ~t2, ~r, ~r1, ~r2)
	]

// the server forwards the blinded tokens to the TI
rule Srv_forward_to_Ti [derivchecks]:
    let msg = <'1', $Usr, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
        tokens = <Usr1BlindedToken ++ Usr1BlindedToken2 ++ Usr2BlindedToken>
    in
    [
        In(<$Usr, $Srv, msg>),                                                                  // receive the user tokens
        State_Srv_setup($Srv, $Ti, Y)
    ]
    --[
        ForwardTokens($Srv, $Usr, $Ti, tokens)
    ]->
    [
        Out_S($Srv, $Ti, msg),                                                                  // forward the blinded user tokens to the TI securely
        State_Srv_forward($Srv, $Usr, $Ti)
    ]

// TI signs the tokens and sends them back to the server and out over the insecure channel
rule Ti_sign_tokens [derivchecks]:
    let msg = <'1', $Usr, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
	
		// T~ = T^sk, sign the blinded token      
        Usr1SignedToken=sign(Usr1BlindedToken, secr_key)
        Usr1SignedToken2=sign(Usr1BlindedToken2, secr_key)        
        Usr2SignedToken=sign(Usr2BlindedToken, secr_key)

		// NIZK DLEQ proof for Usr1BlindedToken 
		A = pow(X, ~nonceT) 
        B = pow(Usr1BlindedToken, ~nonceT)                                                                  
        c = h3(X, Y, Usr1BlindedToken, Usr1SignedToken, A, B) 
        s = mod(minus(~nonceT, multiply(c, secr_key)), ord)
		
		// NIZK DLEQ proof for Usr1BlindedToken2
		A1 = pow(X, ~nonceT1) 		
        B1 = pow(Usr1BlindedToken2, ~nonceT1)                                                                  
        c1 = h3(X, Y, Usr1BlindedToken2, Usr1SignedToken2, A1, B1) 
        s1 = mod(minus(~nonceT1, multiply(c1, secr_key)), ord)
		
		// NIZK DLEQ proof for Usr2BlindedToken 
		A2 = pow(X, ~nonceT2) 		
        B2 = pow(Usr2BlindedToken, ~nonceT2)                                                                  
        c2 = h3(X, Y, Usr2BlindedToken, Usr2SignedToken, A2, B2) 
        s2 = mod(minus(~nonceT2, multiply(c2, secr_key)), ord)
		
        msg_out=<SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
    in
    [ 
		In_S($Srv, $Ti, msg),                                                                   // the token issuer received the blinded tokens from the server
		State_Ti_setup($Ti, X, Y, ord, secr_key),
		Fr(~nonceT),                                                                            // the token issuer generates fresh nonces
		Fr(~nonceT1),
		Fr(~nonceT2)
	]
    --[ 
        GenProof($Ti, $Usr, msg_out),
        Srv_forward_sent($Srv, $Ti, msg_out)
    ]->
    [ 
        Out_S($Ti, $Srv, msg_out),                                                              // send the signed blinded tokens and the proofs to the server
        Out(msg_out)                                                                            // send the signed blinded tokens and the proofs over the insecure channel
    ]

// the server forwards the signed tokens to the user
rule Srv_forward_Ti_tokens:
    [
        In_S($Ti, $Srv, msg),                                                                   // receive the TI-signed tokens
        State_Srv_forward($Srv, $Usr, $Ti)
    ]
    --[
        SrvForwardToken($Srv, $Usr, msg),
        Srv_forward_rcv($Srv, $Ti, msg)
    ]->
    [
        Out(<$Srv, $Usr, msg>)                                                                  // forward the signed tokens to the user over the insecure channel
    ]

// the user receives the tokens from the server and saves them in their state
rule Usr_receives_signed:
    [
        In(<$Srv, $Usr, msg>)                                                                   // receive the tokens from the server
    ]
    --[
        UsrRcvSignedTokens($Srv, $Usr, msg)
    ]->
    [
        State_Usr_signedTok($Usr, $Srv, msg)                                                    // store the tokens in the state
    ]

// the user unblinds the tokens and computes the key and MAC values corresponding to each token
rule Usr_unblind_tokens [derivchecks]:
    let
		msg=<SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
		
        // Verify NIZK DLEQ proof for Usr1BlindedToken
		P = blind(h1(t), r) 
		Q = Usr1SignedToken
		A = calcA(multiply(pow(X, s), pow(Y, c)))
        B = calcB(multiply(pow(P, s), pow(Q, c)))
        c_verify = h3(X, Y, P, Q, A, B)

		// Verify NIZK DLEQ proof for Usr1BlindedToken2
		P1 = blind(h1(t1), r1) 
		Q1 = Usr1SignedToken2
		A1 = calcA(multiply(pow(X, s1), pow(Y, c1)))
        B1 = calcB(multiply(pow(P1, s1), pow(Q1, c1)))
        c1_verify = h3(X, Y, P1, Q1, A1, B1)
		
		// Verify NIZK DLEQ proof for Usr2BlindedToken
		P2 = blind(h1(t2), r2) 
		Q2 = Usr2SignedToken
		A2 = calcA(multiply(pow(X, s2), pow(Y, c2)))
        B2 = calcB(multiply(pow(P2, s2), pow(Q2, c2)))
        c2_verify = h3(X, Y, P2, Q2, A2, B2)		
		
        // unblind the TI signed blinded tokens
		Usr1UnblindedToken=unblind(Usr1SignedToken, r)
        Usr1UnblindedToken2=unblind(Usr1SignedToken2, r1)
        Usr2UnblindedToken=unblind(Usr2SignedToken, r2)
		
        // compute the shared key and MAC for Usr1UnblindedToken
        Usr1TokenKey = h2(t, Usr1UnblindedToken)
        Usr1TokenMAC = MAC(Usr1TokenKey, ~request)

        // compute the shared key and MAC for Usr1UnblindedToken2
        Usr1Token2Key = h2(t2, Usr1UnblindedToken2)
        Usr1Token2MAC = MAC(Usr1Token2Key, ~request1)

        // compute the shared key and MAC for Usr2UnblindedToken
        Usr2TokenKey = h2(t1, Usr2UnblindedToken)
        Usr2TokenMAC = MAC(Usr2TokenKey, ~request2)
		
		seeds=<t, t1, t2>
    in
    [   
        State_Usr_signedTok($Usr, $Srv, msg),                                                   // retrieve the tokens from the state
        State_Usr_blind($Usr, $Srv, X, Y, t, t1, t2, r, r1, r2),
		Fr(~request),                                                                           // the user generates fresh requests
		Fr(~request1),
		Fr(~request2)
    ]
    --[ 
		// verify the DLEQ proofs
        Eq(c, c_verify),                                                                                            
		Eq(c1, c1_verify),
		Eq(c2, c2_verify),
		Show(Usr1UnblindedToken, Usr1UnblindedToken2, Usr2UnblindedToken),
        UnblindedTok($Usr, $Srv, msg, seeds)     
    ]->
    [
        Out(< <t, Usr1TokenMAC>, <t2, Usr1Token2MAC>, <t1, Usr2TokenMAC> >)
    ]

/*
* Correctness lemma
*/
lemma correctness: exists-trace
" Ex user server ti Y tokens seeds secr_key signed_tokens_msg
    #t00 #t01 #t02 #t03 #t04 #t05 #t06
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y) @ t01
    & SendToken(user, server, tokens, seeds) @ t02
    & ForwardTokens(server, user, ti, tokens) @ t03
    & GenProof(ti, user, signed_tokens_msg) @ t04
    & SrvForwardToken(server, user, signed_tokens_msg) @ t05
    & UnblindedTok(user, server, signed_tokens_msg, seeds) @ t06
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & #t03 < #t04
    & #t04 < #t05
    & #t05 < #t06
    & not(user = server) & not(user = ti) & not(ti = server)
"

/*
* The adversary is able to generate tokens 
*/
lemma adversary_generates_tokens: exists-trace
" Ex user server ti Y tokens1 tokens2 seeds secr_key signed_tokens_msg
    #t00 #t01 #t02 #t03 #t04 #t05
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y) @ t01
    & SendToken(user, server, tokens1, seeds) @ t02
    & ForwardTokens(server, user, ti, tokens2) @ t03
    & GenProof(ti, user, signed_tokens_msg) @ t04
    & SrvForwardToken(server, user, signed_tokens_msg) @ t05
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & #t03 < #t04
    & #t04 < #t05
    & not(user = server) & not(user = ti) & not(ti = server) & not(tokens1 = tokens2)
"

/*
* The tokens generated by the adversary do not pass the NIZK DLEQ verification done by the user
*/
lemma adversary_tokens_not_verified:
" All user server ti Y tokens1 tokens2 seeds secr_key signed_tokens_msg
    #t00 #t01 #t02 #t03 #t04 #t05 #t06
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y) @ t01
    & SendToken(user, server, tokens1, seeds) @ t02
    & ForwardTokens(server, user, ti, tokens2) @ t03
    & GenProof(ti, user, signed_tokens_msg) @ t04
    & SrvForwardToken(server, user, signed_tokens_msg) @ t05
	& UnblindedTok(user, server, signed_tokens_msg, seeds) @ t06
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & #t03 < #t04
    & #t04 < #t05
	& #t05 < #t06
    & not(user = server) & not(user = ti) & not(ti = server)
    // the only way this works is if the tokens the user sent are the same that the TI signed
	==> (tokens1 = tokens2)
"

/*
* The adversary is able to inject data between the TI and Srv
*/
lemma adversary_injects_msgs: exists-trace
" Ex user server tokens1 seeds msg
    #t01 #t02
    .
    SendToken(user, server, tokens1, seeds) @ t01
    & UsrRcvSignedTokens(server, user, msg) @ t02
    & #t01 < #t02
    & not(user = server)
"

/*
* The adversary is able to inject data between the TI and Srv but they do not pass the NIZK DLEQ verification done by the user 
*/
lemma adversary_injects_msgs_not_verified: 
" All user server tokens1 seeds msg
    #t01 #t02 #t03
    .
    SendToken(user, server, tokens1, seeds) @ t01
    & UsrRcvSignedTokens(server, user, msg) @ t02
    & UnblindedTok(user, server, msg, seeds) @ t03
    & #t01 < #t02
    & #t02 < #t03
    & not(user = server)
    // the only way this works is if the TI signed the tokens
    ==>
        ( 
            Ex Ti Usr msg_out #k . GenProof(Ti, Usr, msg_out) @ k
            & #k < #t02
        )
"

end