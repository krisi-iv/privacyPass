/* 
Protocol: PP+_2

Instructions to run: 
automatic: tamarin-prover pp_plus_2_1.spthy --prove --derivcheck-timeout=500
interactive: tamarin-prover interactive pp_plus_2_1.spthy --derivcheck-timeout=500

Results:
All wellformedness checks were successful. 


Generated from:
Tamarin version 1.10.0
Maude version 3.1
Git revision: cb62c305f8c8b8c1e664152aa33c95b7b8d5ef32, branch: master
Compiled at: 2024-12-10 08:55:12.367514209 UTC

end

==============================================================================
summary of summaries:

analyzed: pp_plus_2_1.spthy

  processing time: 617.79s

  correctness (exists-trace): verified (27 steps)
  adversary_generates_tokens (exists-trace): verified (6 steps)
  adversary_tokens_not_verified (all-traces): verified (2 steps)
  adversary_injects_msgs (exists-trace): verified (3 steps)
  adversary_injects_msgs_not_verified (all-traces): verified (40 steps)

==============================================================================

*/

theory PrivacyPassPlusUnlinkability_PP_Plus_2_1
begin

heuristic: O "pp_plus_unlinkability.oracle"
 
builtins: multiset

functions: h1/1, h2/2, h3/6, blind/2, sign/2, unblind/2, 
        pow/2, mod/2, multiply/2, minus/2,                                                      // mathematical functions used in the protocol 
        calcA/1, calcB/1,                                                                       // functions to recalculate A and B in the DLEQ proof
        MAC/2,
		//Partial deconstructions
        BlindedToken/1, SignedToken/1, SrvSignedToken/1, CHash/1, SMod/1
equations [convergent]:
	unblind(sign(blind(h1(x),r),secr_key),r) = sign(h1(x),secr_key),                            // unblind the blinded signed token
	unblind(sign(sign(blind(h1(x),r),secr_key1),secr_key2),r) = sign(sign(h1(x),secr_key1),secr_key2),          // unblind the blinded double signed token

    // Recalculate A in the DLEQ proof: A = X^s * Y^c = X^((t-(h3(X, Y, P, Q, Xt, Pt)*k)) mod q) * X^k^h3(X, Y, P, Q, Xt, Pt) = Xt, where t is a random nonce
    calcA(
        multiply(
            pow(X, mod(minus(t, multiply(h3(X, Y, P, Q, Xt, Pt), k)), q)),
            pow(pow(X, k), h3(X, Y, P, Q, Xt, Pt))
        )
        ) = Xt,
    // Recalculate B in the DLEQ proof: B = P^s * P^c = P^((t-(h3(X, Y, P, Q, Xt, Pt)*k)) mod q) * P^k^h3(X, Y, P, Q, Xt, Pt) = Pt, where t is a random nonce
    calcB(
        multiply(
            pow(P, mod(minus(t, multiply(h3(X, Y, P, Q, Xt, Pt), k)), q)),
            pow(sign(P, k), h3(X, Y, P, Q, Xt, Pt))
        )
    ) = Pt
	
// the following restriction is used to allow only a single instance of the token issuer to be created in the protocol for this implementation
restriction single_ti: "All #i #j ti Y sk1 ti2 Y2 sk2. Setup_Ti(ti, Y, sk1) @ i & Setup_Ti(ti2, Y2, sk2) @ j ==> #i = #j"
// used to check the solution is indeed correct, the equality in the DLEQ proof holds, the token is stored in the token issuer's data store, and the MACs are equal
restriction equality: "All #i x y. Eq(x , y) @ i ==> x = y"

// the following two rules are used to model the secure channel used in the protocol
rule ChanOut_S:
    [ Out_S($A,$B,x) ]
    --[ ChanOut_S($A,$B,x) ]->
    [ Sec($A,$B,x) ]

rule ChanIn_S:
    [ Sec($A,$B,x) ]
    --[ ChanIn_S($A,$B,x) ]->
    [ In_S($A,$B,x) ]

// setting up the token issuer with its secret key, the order of the group, the generators of the group, and the commitments
rule Setup_Ti:
    let Y = pow(X,secr_key)                                                                     // Y = X^sk
    in
    [ 
        Fr(X), 
        Fr(ord),                                                                                // the order of the group 
        Fr(secr_key)                                                                            // the secret signing key of the token issuer
    ]
    --[ 
        Setup_Ti($Ti, Y, secr_key)
    ]->
    [ 
        State_Ti_setup($Ti, X, Y, ord, secr_key), 
        State_Srv_Ti($Ti, Y), 
        !State_Usr_Ti($Ti, X)
    ]

// setting up the server with the commitment of the token issuer and knowledge of the token issuer
rule Setup_Srv:
    [ 
        Fr(secr_key_srv), 
        State_Srv_Ti($Ti, Y) 
    ]
    --[ 
        Setup_Srv($Ti, $Srv, Y, secr_key_srv)
    ]->
    [ 
        State_Srv_setup($Srv, $Ti, Y, secr_key_srv),
        !State_Srv_Usr($Srv, $Ti, Y)
    ]

// setting up the user with the commitment of the token issuer and knowledge of the server
rule Setup_Usr:
    [ 
        !State_Usr_Ti($Ti, X), 
        !State_Srv_Usr($Srv, $Ti, Y)
    ]
    --[ 
        Setup_Usr($Usr, $Srv, Y)
    ]->
    [ 
        State_Usr_setup($Usr, $Srv, X, Y)
    ]

// User generates blinded tokens - 2 for user1 and 1 for user2 and sends them to the server
rule Usr_send_token:
    let
        Usr1BlindedToken = blind(h1(~t), ~r)                                                    // T=H(~t), blind T: T~ = T^r
        Usr1BlindedToken2 = blind(h1(~t1), ~r1) 
        Usr2BlindedToken = blind(h1(~t2), ~r2)
        seeds = <~t, ~t1, ~t2>
        tokens = <Usr1BlindedToken + Usr1BlindedToken2 + Usr2BlindedToken>
        msg = <$Usr, $Srv, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
    in
    [ 
        Fr(~t),                                                                                 // the users generate fresh seed values for the blinded tokens
        Fr(~t1), 
        Fr(~t2),
        Fr(~r),                                                                                 // the user generates fresh randomisation values for the blinded tokens
        Fr(~r1),
        Fr(~r2),
        State_Usr_setup($Usr, $Srv, X, Y)
    ] 
    --[ SendToken($Usr, $Srv, tokens, seeds) ]->
    [ 
        Out(<$Usr, $Srv, msg>),                                                                 // send the blinded tokens to the server insecurely
        State_Usr_blind($Usr, $Srv, X, Y, ~t, ~t1, ~t2, ~r, ~r1, ~r2)
    ]

rule Srv_forwards_tokent_to_TI:
    let msg = <$Usr, $Srv, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
        tokens = <Usr1BlindedToken + Usr1BlindedToken2 + Usr2BlindedToken>
        out_msg = <$Srv, $Ti, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
    in
    [
        In(<$Usr, $Srv, msg>),                                                                  // the server received the blinded tokens from the user
        State_Srv_setup($Srv, $Ti, Y, secr_key_srv),
    ]
    --[
        ForwardTokens($Srv, $Usr, $Ti, tokens)
    ]->
    [
        Out_S($Srv, $Ti, out_msg),                                                                  // forward the blinded user tokens to the TI securely
        State_Srv_forward($Srv, $Usr, $Ti, secr_key_srv)
    ]

// token issuer signs the tokens and tsends them to the server for it to sign
rule Ti_sign_tokens:
    let msg = <$Srv, $Ti, Usr1BlindedToken, Usr1BlindedToken2, Usr2BlindedToken>
		tokens = <Usr1BlindedToken + Usr1BlindedToken2 + Usr2BlindedToken>
		
        // token issuer signs the tokens
        Usr1SignedToken=sign(Usr1BlindedToken, secr_key)                                                    
        Usr1SignedToken2=sign(Usr1BlindedToken2, secr_key)
        Usr2SignedToken=sign(Usr2BlindedToken, secr_key)

        // NIZK DLEQ proof for Usr1BlindedToken
		A = pow(X, ~nonceT)
        B = pow(Usr1BlindedToken, ~nonceT)                                                                  
        c = h3(X, Y, Usr1BlindedToken, Usr1SignedToken, A, B) 
        s = mod(minus(~nonceT, multiply(c, secr_key)), ord)

		// NIZK DLEQ proof for Usr1BlindedToken2 
        A1 = pow(X, ~nonceT1) 	
        B1 = pow(Usr1BlindedToken2, ~nonceT1)                                                                  
        c1 = h3(X, Y, Usr1BlindedToken2, Usr1SignedToken2, A1, B1) 
        s1 = mod(minus(~nonceT1, multiply(c1, secr_key)), ord)

		// NIZK DLEQ proof for Usr2BlindedToken        
        A2 = pow(X, ~nonceT2) 	
        B2 = pow(Usr2BlindedToken, ~nonceT2)                                                                  
        c2 = h3(X, Y, Usr2BlindedToken, Usr2SignedToken, A2, B2) 
        s2 = mod(minus(~nonceT2, multiply(c2, secr_key)), ord)

        msg_out = <$Ti, $Srv, SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
    in
    [ 
        In_S($Srv, $Ti, msg),                                                                   // the token issuer received the blinded tokens from the server
        State_Ti_setup($Ti, X, Y, ord, secr_key),
		Fr(~nonceT),                                                                            // the token issuer generates fresh nonces
		Fr(~nonceT1),
		Fr(~nonceT2)
    ]
    --[ 
        GenProof($Ti, $Srv, tokens, msg_out)
    ]->
    [ 
		Out_S($Ti, $Srv, msg_out)                                                               // send the signed blinded tokens and the proofs to the server
	]  

// the server signs the tokens and sends them back to the user over the insecure channel
rule Srv_sign_tokens [derivchecks]:
    let msg = <$Ti, $Srv, SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
		
		// Server signs the tokens
		Usr1srvSignedToken = sign(Usr1SignedToken, secr_key_srv)
        Usr1srvSignedToken2 = sign(Usr1SignedToken2, secr_key_srv)
        Usr2srvSignedToken = sign(Usr2SignedToken, secr_key_srv)

        msg_out = <$Srv, $Usr, SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), SrvSignedToken(Usr1srvSignedToken), SrvSignedToken(Usr1srvSignedToken2), SrvSignedToken(Usr2srvSignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
    in
    [ 
        In_S($Ti, $Srv, msg),                                                                   // the server received the blinded tokens from the user
        State_Srv_forward($Srv, $Usr, $Ti, secr_key_srv)
    ]
    --[ 
        SrvSignsTokens($Srv, $Usr, msg_out)
    ]->
    [
        Out(<$Srv, $Usr, msg_out>)                                                              // send the signed blinded tokens and the proofs to the user over the insecure channel
	]  

// the user receives the tokens from the server and saves them in their state
rule Usr_receives_signed:
    [
        In(<$Srv, $Usr, msg>)                                                                   // receive the tokens from the server
    ]
    --[
        UsrRcvSignedTokens($Srv, $Usr, msg)
    ]->
    [
        State_Usr_signedTok($Usr, $Srv, msg)                                                    // store the tokens in the state
    ]

// the user verifies the token issuer's NIZK proofs on the tokens and unblinds the tokens signed by the token issuer
rule Usr_verify_tokens [derivchecks]:
    let msg_in = <$Srv, $Usr, SignedToken(Usr1SignedToken), SignedToken(Usr1SignedToken2), SignedToken(Usr2SignedToken), SrvSignedToken(Usr1srvSignedToken), SrvSignedToken(Usr1srvSignedToken2), SrvSignedToken(Usr2srvSignedToken), CHash(c), SMod(s), CHash(c1), SMod(s1), CHash(c2), SMod(s2)>
		seeds = <t, t1, t2>
        
        // Verify NIZK DLEQ proof for Usr1BlindedToken
        P = blind(h1(t), r) 
		Q = Usr1SignedToken                                                                   
        A = calcA(multiply(pow(X, s), pow(Y, c)))
        B = calcB(multiply(pow(P, s), pow(Q, c)))
        c_v = h3(X, Y, P, Q, A, B)

        // Verify NIZK DLEQ proof for Usr1BlindedToken2
        P1 = blind(h1(t1), r1) 
		Q1 = Usr1SignedToken2                                                                   
        A1 = calcA(multiply(pow(X, s1), pow(Y, c1)))
        B1 = calcB(multiply(pow(P1, s1), pow(Q1, c1)))
        c1_v = h3(X, Y, P1, Q1, A1, B1)

        // Verify NIZK DLEQ proof for Usr2BlindedToken
        P2 = blind(h1(t2), r2) 
		Q2 = Usr2SignedToken                                                                   
        A2 = calcA(multiply(pow(X, s2), pow(Y, c2)))
        B2 = calcB(multiply(pow(P2, s2), pow(Q2, c2)))
        c2_v = h3(X, Y, P2, Q2, A2, B2)
		
        // unblind the token issuer signed tokens
		Usr1unblinded = unblind(Usr1SignedToken, r)
        Usr1unblinded2 = unblind(Usr1SignedToken2,r1)
        Usr2unblinded = unblind(Usr2SignedToken,r2)
    in
    [
        State_Usr_signedTok($Usr, $Srv, msg_in),                                                // retrieve the tokens from the state
        State_Usr_blind($Usr, $Srv, X, Y, t, t1, t2, r, r1, r2),
    ]
    --[ 
        // verify the DLEQ proofs
        Eq(c, c_v),
        Eq(c1, c1_v),
        Eq(c2, c2_v),
        VerifyTok($Usr, $Srv, msg_in, seeds)
    ]->
    [
		State_Usr_unblind($Usr, $Srv, $Ti, X, Y, t, t1, t2, r, r1, r2, Usr1unblinded, Usr1unblinded2, Usr2unblinded, Usr1srvSignedToken, Usr1srvSignedToken2, Usr2srvSignedToken)                           // use the state to forward the tokens to the next user rule
    ]

// the user generates fresh requests, unblinds the TI and server signed blinded tokens, computes the shared keys with the TI and server and the MACs for each token
rule User_Generates_Request:
    let seeds = <t, t1, t2>
		
		// unblind User1's first server token, compute the keys and MACs for each unblinded token signed by the token issuer and by the server, and create a request
        Usr1UnblindedSrvToken=unblind(Usr1srvSignedToken, r)                                    // unblind the first TI and Server blinded signed token
		key1=h2(t, Usr1unblinded)                                                               // compute the shared key with the TI 
		s1 = MAC(key1, ~request)                                                               // compute the MAC for the TI
		Usr1Token_key_verify_srvSignedToken = h2(t, Usr1UnblindedSrvToken)                      // compute the shared key with the server
		Usr1Token_hash_srvSignedToken = MAC(Usr1Token_key_verify_srvSignedToken, ~request)     // compute the MAC for the server
		
		// unblind User1's second server token, compute the keys and MACs for each unblinded token signed by the token issuer and by the server, and create a request
		Usr1UnblindedSrvToken2=unblind(Usr1srvSignedToken2, r1)
		key2=h2(t1, Usr1unblinded2)
		s2 = MAC(key2, ~request1)
		Usr1Token_key_verify_srvSignedToken2 = h2(t1, Usr1UnblindedSrvToken2)
		Usr1Token2_hash_srvSignedToken = MAC(Usr1Token_key_verify_srvSignedToken2, ~request1)
		
		// unblind User2's server token, compute the keys and MACs for each unblinded token signed by the token issuer and by the server, and create a request
        Usr2UnblindedSrvToken=unblind(Usr2srvSignedToken, r2)
		key3=h2(t2, Usr2unblinded)
		s3 = MAC(key3, ~request2)
		Usr2Token_key_verify_srvSignedToken = h2(t, Usr2UnblindedSrvToken)
		Usr2Token_hash_srvSignedToken = MAC(Usr2Token_key_verify_srvSignedToken, ~request2)
    in
    [
        State_Usr_unblind($Usr, $Srv, $Ti, X, Y, t, t1, t2, r, r1, r2, Usr1unblinded, Usr1unblinded2, Usr2unblinded, Usr1srvSignedToken, Usr1srvSignedToken2, Usr2srvSignedToken),                           // retrieve the tokens
        Fr(~request),                                                                           // generate fresh requests
		Fr(~request1),
		Fr(~request2)
    ]
    --[ 
        CreateRequests($Usr, $Srv, seeds)
    ]->
    [
        Out(<<t, s1, Usr1Token_hash_srvSignedToken>, <t1, s2, Usr1Token2_hash_srvSignedToken>, <t2, s3, Usr2Token_hash_srvSignedToken> >)
    ]

/*
* Correctness lemma
*/
lemma correctness: exists-trace
" Ex user server ti Y secr_key secr_key_srv tokens proof_sigs seeds msg
    #t00 #t01 #t02 #t03 #t04 #t05 #t06 #t07
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y, secr_key_srv) @ t01
    & SendToken(user, server, tokens, seeds) @ t02
    & ForwardTokens(server, user, ti, tokens) @ t03
    & GenProof(ti, server, tokens, proof_sigs) @ t04
    & SrvSignsTokens(server, user, msg) @ t05
    & VerifyTok(user, server, msg, seeds) @ t06
	& CreateRequests(user, server, seeds) @ t07
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & #t03 < #t04
	& #t04 < #t05
    & #t05 < #t06
	& #t06 < #t07
    & not(user = server) & not(user = ti) & not(ti = server)
"

/*
* The adversary is able to generate tokens 
*/
lemma adversary_generates_tokens: exists-trace
" Ex user server ti Y secr_key secr_key_srv proof_sigs tokens1 tokens2 seeds 
    #t00 #t01 #t02 #t03
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y, secr_key_srv) @ t01
    & SendToken(user, server, tokens1, seeds) @ t02
    & GenProof(ti, server, tokens2, proof_sigs) @ t03
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & not(user = server) & not(user = ti) & not(ti = server) & not(tokens1 = tokens2)
"

/*
* The tokens generated by the adversary do not pass the NIZK DLEQ verification done by the user
*/
lemma adversary_tokens_not_verified:
" All user server ti Y secr_key secr_key_srv proof_sigs tokens1 tokens2 seeds msg
    #t00 #t01 #t02 #t03 #t04 #t05
    .
    Setup_Ti(ti, Y, secr_key) @ t00
    & Setup_Srv(ti, server, Y, secr_key_srv) @ t01
    & SendToken(user, server, tokens1, seeds) @ t02
    & GenProof(ti, server, tokens2, proof_sigs) @ t03
    & SrvSignsTokens(ti, server, msg) @ t04
    & VerifyTok(user, server, msg, seeds) @ t05
    & #t00 < #t01
    & #t01 < #t02
    & #t02 < #t03
    & #t03 < #t04
    & #t04 < #t05
    & not(user = server) & not(user = ti) & not(ti = server)
    // the only way this works is if the tokens the user sent are the same that the TI signed
	==> (tokens1 = tokens2)
"

/*
* The adversary is able to inject data between the Srv and Usr
*/
lemma adversary_injects_msgs: exists-trace
" Ex user server tokens1 seeds msg
    #t01 #t02
    .
    SendToken(user, server, tokens1, seeds) @ t01
    & UsrRcvSignedTokens(server, user, msg) @ t02
    & #t01 < #t02
    & not(user = server)
"

/*
* The adversary is able to inject data between the TI and Srv but they do not pass the NIZK DLEQ verification done by the user
*/
lemma adversary_injects_msgs_not_verified:
" All user server tokens1 seeds msg
    #t01 #t02 #t03
    .
    SendToken(user, server, tokens1, seeds) @ t01
    & UsrRcvSignedTokens(server, user, msg) @ t02
    & VerifyTok(user, server, msg, seeds) @ t03
    & #t01 < #t02
    & #t02 < #t03
    & not(user = server)
    // the only way this works is if the TI signed the tokens
    ==>
		(
            Ex Ti USR msg_out #k . GenProof(Ti, USR, tokens1, msg_out) @ k
            & #k < #t02
		)
"

end
